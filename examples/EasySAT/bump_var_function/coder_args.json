{
    "task": "schedule_plan",
    "prompt_fpath": "",
    "modification_direction": "",
    "description": "",
    "origin_description": "At present, I have a multi-task cluster problem, there are multiple robots and multiple tasks, the number of tasks is much larger than the robot, first of all, a certain number of tasks will be pre-assigned, if the robot completes a task, a new task will be issued, the robot and the task are in an m*m grid, the goal is to complete as many tasks as possible. My current code is to find the task with the shortest time to complete first, but this does not take into account the global optimal, pay attention to the function will be constantly called, every second needs to plan the task of the idle robot",
    "origin_key_code": "#include \"scheduler.h\"\n\nnamespace DefaultPlanner{\n\nstd::mt19937 mt;\nstd::unordered_set<int> free_agents;\nstd::unordered_set<int> free_tasks;\n\nvoid schedule_initialize(int preprocess_time_limit, SharedEnvironment* env)\n{\n    // cout<<\"schedule initialise limit\" << preprocess_time_limit<<endl;\n    DefaultPlanner::init_heuristics(env);\n    mt.seed(0);\n    return;\n}\n\nvoid schedule_plan(int time_limit, std::vector<int> & proposed_schedule,  SharedEnvironment* env)\n{\n\n    //so that the remainning time are left for path planner\n    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);\n    // cout<<\"schedule plan limit\" << time_limit <<endl;\n\n    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps\n    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());\n    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());\n\n    int min_task_i, min_task_makespan, dist, c_loc, count;\n    clock_t start = clock();\n\n    // iterate over the free agents to decide which task to assign to each of them\n    std::unordered_set<int>::iterator it = free_agents.begin();\n    while (it != free_agents.end())\n    {\n        //keep assigning until timeout\n        if (std::chrono::steady_clock::now() > endtime)\n        {\n            break;\n        }\n        int i = *it;\n\n        assert(env->curr_task_schedule[i] == -1);\n            \n        min_task_i = -1;\n        min_task_makespan = INT_MAX;\n        count = 0;\n\n        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i\n        for (int t_id : free_tasks)\n        {\n            //check for timeout every 10 task evaluations\n            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)\n            {\n                break;\n            }\n            dist = 0;\n            c_loc = env->curr_states.at(i).location;\n\n            // iterate over the locations (errands) of the task to compute the makespan to finish the task\n            // makespan: the time for the agent to complete all the errands of the task t_id in order\n            for (int loc : env->task_pool[t_id].locations){\n                dist += DefaultPlanner::get_h(env, c_loc, loc);\n                c_loc = loc;\n            }\n\n            // update the new minimum makespan\n            if (dist < min_task_makespan){\n                min_task_i = t_id;\n                min_task_makespan = dist;\n            }\n            count++;            \n        }\n\n        // assign the best free task to the agent i (assuming one exists)\n        if (min_task_i != -1){\n            proposed_schedule[i] = min_task_i;\n            it = free_agents.erase(it);\n            free_tasks.erase(min_task_i);\n        }\n        // nothing to assign\n        else{\n            proposed_schedule[i] = -1;\n            it++;\n        }\n    }\n    #ifndef NDEBUG\n    cout << \"Time Usage: \" <<  ((float)(clock() - start))/CLOCKS_PER_SEC <<endl;\n    cout << \"new free agents: \" << env->new_freeagents.size() << \" new tasks: \"<< env->new_tasks.size() <<  endl;\n    cout << \"free agents: \" << free_agents.size() << \" free tasks: \" << free_tasks.size() << endl;\n    #endif\n    return;\n}\n}\n",
    "origin_target_code": "void schedule_plan(int time_limit, std::vector<int> & proposed_schedule,  SharedEnvironment* env)\n{\n\n    //so that the remainning time are left for path planner\n    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);\n    // cout<<\"schedule plan limit\" << time_limit <<endl;\n\n    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps\n    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());\n    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());\n\n    int min_task_i, min_task_makespan, dist, c_loc, count;\n    clock_t start = clock();\n\n    // iterate over the free agents to decide which task to assign to each of them\n    std::unordered_set<int>::iterator it = free_agents.begin();\n    while (it != free_agents.end())\n    {\n        //keep assigning until timeout\n        if (std::chrono::steady_clock::now() > endtime)\n        {\n            break;\n        }\n        int i = *it;\n\n        assert(env->curr_task_schedule[i] == -1);\n            \n        min_task_i = -1;\n        min_task_makespan = INT_MAX;\n        count = 0;\n\n        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i\n        for (int t_id : free_tasks)\n        {\n            //check for timeout every 10 task evaluations\n            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)\n            {\n                break;\n            }\n            dist = 0;\n            c_loc = env->curr_states.at(i).location;\n\n            // iterate over the locations (errands) of the task to compute the makespan to finish the task\n            // makespan: the time for the agent to complete all the errands of the task t_id in order\n            for (int loc : env->task_pool[t_id].locations){\n                dist += DefaultPlanner::get_h(env, c_loc, loc);\n                c_loc = loc;\n            }\n\n            // update the new minimum makespan\n            if (dist < min_task_makespan){\n                min_task_i = t_id;\n                min_task_makespan = dist;\n            }\n            count++;            \n        }\n\n        // assign the best free task to the agent i (assuming one exists)\n        if (min_task_i != -1){\n            proposed_schedule[i] = min_task_i;\n            it = free_agents.erase(it);\n            free_tasks.erase(min_task_i);\n        }\n        // nothing to assign\n        else{\n            proposed_schedule[i] = -1;\n            it++;\n        }\n    }\n    return;\n}",
    "code_format": "void schedule_plan(int time_limit, std::vector<int> & proposed_schedule,  SharedEnvironment* env)  {\n    ...    \n}",
    "origin_result": "",
    "experiment_results": "",
    "best_code": "",
    "best_code_description": ""
}