{
    "task": "schedule_plan",
    "prompt_fpath": "",
    "origin_key_code": "",
    "origin_target_code": "void schedule_plan(int time_limit, std::vector<int> & proposed_schedule,  SharedEnvironment* env)\n{\n\n    //so that the remainning time are left for path planner\n    TimePoint endtime = std::chrono::steady_clock::now() + std::chrono::milliseconds(time_limit);\n    // cout<<\"schedule plan limit\" << time_limit <<endl;\n\n    // the default scheduler keep track of all the free agents and unassigned (=free) tasks across timesteps\n    free_agents.insert(env->new_freeagents.begin(), env->new_freeagents.end());\n    free_tasks.insert(env->new_tasks.begin(), env->new_tasks.end());\n\n    int min_task_i, min_task_makespan, dist, c_loc, count;\n    clock_t start = clock();\n\n    // iterate over the free agents to decide which task to assign to each of them\n    std::unordered_set<int>::iterator it = free_agents.begin();\n    while (it != free_agents.end())\n    {\n        //keep assigning until timeout\n        if (std::chrono::steady_clock::now() > endtime)\n        {\n            break;\n        }\n        int i = *it;\n\n        assert(env->curr_task_schedule[i] == -1);\n            \n        min_task_i = -1;\n        min_task_makespan = INT_MAX;\n        count = 0;\n\n        // iterate over all the unassigned tasks to find the one with the minimum makespan for agent i\n        for (int t_id : free_tasks)\n        {\n            //check for timeout every 10 task evaluations\n            if (count % 10 == 0 && std::chrono::steady_clock::now() > endtime)\n            {\n                break;\n            }\n            dist = 0;\n            c_loc = env->curr_states.at(i).location;\n\n            // iterate over the locations (errands) of the task to compute the makespan to finish the task\n            // makespan: the time for the agent to complete all the errands of the task t_id in order\n            for (int loc : env->task_pool[t_id].locations){\n                dist += DefaultPlanner::get_h(env, c_loc, loc);\n                c_loc = loc;\n            }\n\n            // update the new minimum makespan\n            if (dist < min_task_makespan){\n                min_task_i = t_id;\n                min_task_makespan = dist;\n            }\n            count++;            \n        }\n\n        // assign the best free task to the agent i (assuming one exists)\n        if (min_task_i != -1){\n            proposed_schedule[i] = min_task_i;\n            it = free_agents.erase(it);\n            free_tasks.erase(min_task_i);\n        }\n        // nothing to assign\n        else{\n            proposed_schedule[i] = -1;\n            it++;\n        }\n    }\n    return;\n}",
    "llm_generation": ""
}